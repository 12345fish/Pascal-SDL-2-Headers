
{**
 *   Audio format flags.
 *
 *  These are what the 16 bits in SDL_AudioFormat currently mean...
 *  (Unspecified bits are always zero).
 *
 *  
    ++-----------------------sample is signed if set
    ||
    ||       ++-----------sample is bigendian if set
    ||       ||
    ||       ||          ++---sample is float if set
    ||       ||          ||
    ||       ||          || +---sample bit size---+
    ||       ||          || |                     |
    15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
 *
 *  There are macros in SDL 2.0 and later to query these bits.
 *}
type
  SDL_AudioFormat: UInt16;

{**
 *   Audio flags
 *}
const
  SDL_AUDIO_MASK_BITSIZE      = ($FF);
  SDL_AUDIO_MASK_DATATYPE     = (1 shl 8);
  SDL_AUDIO_MASK_ENDIAN       = (1 shl 12);
  SDL_AUDIO_MASK_SIGNED       = (1 shl 15);{
  SDL_AUDIO_BITSIZE(x)        = (x and SDL_AUDIO_MASK_BITSIZE)
  SDL_AUDIO_ISFLOAT(x)        = (x and SDL_AUDIO_MASK_DATATYPE)
  SDL_AUDIO_ISBIGENDIAN(x)    = (x and SDL_AUDIO_MASK_ENDIAN)
  SDL_AUDIO_ISSIGNED(x)       = (x and SDL_AUDIO_MASK_SIGNED)
  SDL_AUDIO_ISINT(x)          = (!SDL_AUDIO_ISFLOAT(x))
  SDL_AUDIO_ISLITTLEENDIAN(x) = (!SDL_AUDIO_ISBIGENDIAN(x))
  SDL_AUDIO_ISUNSIGNED(x)     = (!SDL_AUDIO_ISSIGNED(x))}

{**
 *   Audio format flags
 *
 *  Defaults to LSB byte order.
 *}
const
  AUDIO_U8      = $0008;  {**< Unsigned 8-bit samples *}
  AUDIO_S8      = $8008;  {**< Signed 8-bit samples *}
  AUDIO_U16LSB  = $0010;  {**< Unsigned 16-bit samples *}
  AUDIO_S16LSB  = $8010;  {**< Signed 16-bit samples *}
  AUDIO_U16MSB  = $1010;  {**< As above, but big-endian byte order *}
  AUDIO_S16MSB  = $9010;  {**< As above, but big-endian byte order *}
  AUDIO_U16     = AUDIO_U16LSB;
  AUDIO_S16     = AUDIO_S16LSB;

{**
 *   int32 support
 *}
const
  AUDIO_S32LSB  = $8020;  {**< 32-bit integer samples *}
  AUDIO_S32MSB  = $9020;  {**< As above, but big-endian byte order *}
  AUDIO_S32     = AUDIO_S32LSB;

{**
 *   float32 support
 *}
const
  AUDIO_F32LSB  = $8120  {**< 32-bit floating point samples *}
  AUDIO_F32MSB  = $9120  {**< As above, but big-endian byte order *}
  AUDIO_F32     = AUDIO_F32LSB;

{**
 *   Native audio byte ordering
 *}
{
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
#define AUDIO_U16SYS    AUDIO_U16LSB
#define AUDIO_S16SYS    AUDIO_S16LSB
#define AUDIO_S32SYS    AUDIO_S32LSB
#define AUDIO_F32SYS    AUDIO_F32LSB
#else
#define AUDIO_U16SYS    AUDIO_U16MSB
#define AUDIO_S16SYS    AUDIO_S16MSB
#define AUDIO_S32SYS    AUDIO_S32MSB
#define AUDIO_F32SYS    AUDIO_F32MSB
#endif}

{**
 *   Allow change flags
 *
 *  Which audio format changes are allowed when opening a device.
 *}
const
  SDL_AUDIO_ALLOW_FREQUENCY_CHANGE  = $00000001;
  SDL_AUDIO_ALLOW_FORMAT_CHANGE     = $00000002;
  SDL_AUDIO_ALLOW_CHANNELS_CHANGE   = $00000004;
  SDL_AUDIO_ALLOW_ANY_CHANGE        = (SDL_AUDIO_ALLOW_FREQUENCY_CHANGE or
                                       SDL_AUDIO_ALLOW_FORMAT_CHANGE or
									   SDL_AUDIO_ALLOW_CHANNELS_CHANGE);

{*Audio flags*}

{**
 *  This function is called when the audio device needs more data.
 *
 *   userdata An application-specific parameter saved in
 *                  the SDL_AudioSpec structure
 *   stream A pointer to the audio data buffer.
 *   len    The length of that buffer in bytes.
 *
 *  Once the callback returns, the buffer will no longer be valid.
 *  Stereo samples are stored in a LRLRLR ordering.
 *}
TSDL_AudioCallback = procedure(userdata: Pointer; stream: PUInt8; len: Integer);

{**
 *  The calculated values in this structure are calculated by SDL_OpenAudio().
 *}
type
  TSDL_AudioSpec = record
    freq: Integer;                {**< DSP frequency -- samples per second *}
    format: TSDL_AudioFormat;     {**< Audio data format *}
    channels: UInt8;              {**< Number of channels: 1 mono, 2 stereo *}
    silence: UInt8;               {**< Audio buffer silence value (calculated) *}
    samples: UInt16;              {**< Audio buffer size in samples (power of 2) *}
    padding: UInt16;              {**< Necessary for some compile environments *}
    size: UInt32;                 {**< Audio buffer size in bytes (calculated) *}
    callback: TSDL_AudioCallback;
    userdata: Pointer;
  end;


struct SDL_AudioCVT;
typedef void (SDLCALL * SDL_AudioFilter) (struct SDL_AudioCVT * cvt,
                                          SDL_AudioFormat format);

{**
 *  A structure to hold a set of audio conversion filters and buffers.
 *}
  TSDL_AudioCVT = record
    needed: Integer;                		  {**< Set to 1 if conversion possible *}
    src_format: TSDL_AudioFormat; 			  {**< Source audio format *}
    dst_format: TSDL_AudioFormat;			  {**< Target audio format *}
    rate_incr: Double;          			  {**< Rate conversion increment *}
    buf: PUInt8;                			  {**< Buffer to hold entire audio data *}
    len: Integer;                    		  {**< Length of original audio buffer *}
    len_cvt: Integer;               		  {**< Length of converted audio buffer *}
    len_mult: Integer;              		  {**< buffer must be len*len_mult big *}
    len_ratio: Double;          			  {**< Given len, final size is len*len_ratio *}
    filters: array[0..9] of TSDL_AudioFilter; {**< Filter list *}
    filter_index: Integer;           		  {**< Current audio conversion function *}
  end;


{* Function prototypes *}

{**
 *   Driver discovery functions
 *
 *  These functions return the list of built in audio drivers, in the
 *  order that they are normally initialized by default.
 *}

function SDL_GetNumAudioDrivers: Integer;
function SDL_GetAudioDriver(index: Integer): PAnsiChar;

{**
 *   Initialization and cleanup
 *
 *  These functions are used internally, and should not be used unless
 *  you have a specific need to specify the audio driver you want to
 *  use.  You should normally use SDL_Init() or SDL_InitSubSystem().
 *}
 
function SDL_AudioInit(driver_name: PAnsiChar): Integer;
procedure SDL_AudioQuit;

{**
 *  This function returns the name of the current audio driver, or NULL
 *  if no driver has been initialized.
 *}
function SDL_GetCurrentAudioDriver: PAnsiChar;

{**
 *  This function opens the audio device with the desired parameters, and
 *  returns 0 if successful, placing the actual hardware parameters in the
 *  structure pointed to by \c obtained.  If \c obtained is NULL, the audio
 *  data passed to the callback function will be guaranteed to be in the
 *  requested format, and will be automatically converted to the hardware
 *  audio format if necessary.  This function returns -1 if it failed
 *  to open the audio device, or couldn't set up the audio thread.
 *
 *  When filling in the desired audio spec structure,
 *    - desired->freq should be the desired audio frequency in samples-per-
 *      second.
 *    - desired->format should be the desired audio format.
 *    - desired->samples is the desired size of the audio buffer, in
 *      samples.  This number should be a power of two, and may be adjusted by
 *      the audio driver to a value more suitable for the hardware.  Good values
 *      seem to range between 512 and 8096 inclusive, depending on the
 *      application and CPU speed.  Smaller values yield faster response time,
 *      but can lead to underflow if the application is doing heavy processing
 *      and cannot fill the audio buffer in time.  A stereo sample consists of
 *      both right and left channels in LR ordering.
 *      Note that the number of samples is directly related to time by the
 *      following formula:  \code ms = (samples*1000)/freq \endcode
 *    - desired->size is the size in bytes of the audio buffer, and is
 *      calculated by SDL_OpenAudio().
 *    - desired->silence is the value used to set the buffer to silence,
 *      and is calculated by SDL_OpenAudio().
 *    - desired->callback should be set to a function that will be called
 *      when the audio device is ready for more data.  It is passed a pointer
 *      to the audio buffer, and the length in bytes of the audio buffer.
 *      This function usually runs in a separate thread, and so you should
 *      protect data structures that it accesses by calling SDL_LockAudio()
 *      and SDL_UnlockAudio() in your code.
 *    - desired->userdata is passed as the first parameter to your callback
 *      function.
 *
 *  The audio device starts out playing silence when it's opened, and should
 *  be enabled for playing by calling \c SDL_PauseAudio(0) when you are ready
 *  for your audio callback function to be called.  Since the audio driver
 *  may modify the requested size of the audio buffer, you should allocate
 *  any local mixing buffers after you open the audio device.
 *}
function SDL_OpenAudio(desired: PSDL_AudioSpec; obtained: PSDL_AudioSpec): Integer;

{**
 *  SDL Audio Device IDs.
 *
 *  A successful call to SDL_OpenAudio() is always device id 1, and legacy
 *  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
 *  always returns devices >= 2 on success. The legacy calls are good both
 *  for backwards compatibility and when you don't care about multiple,
 *  specific, or capture devices.
 *}
type
  SDL_AudioDeviceID: UInt32;

{**
 *  Get the number of available devices exposed by the current driver.
 *  Only valid after a successfully initializing the audio subsystem.
 *  Returns -1 if an explicit list of devices can't be determined; this is
 *  not an error. For example, if SDL is set up to talk to a remote audio
 *  server, it can't list every one available on the Internet, but it will
 *  still allow a specific host to be specified to SDL_OpenAudioDevice().
 *
 *  In many common cases, when this function returns a value <= 0, it can still
 *  successfully open the default device (NULL for first argument of
 *  SDL_OpenAudioDevice()).
 *}
function SDL_GetNumAudioDevices(iscapture: Integer): Integer;

{**
 *  Get the human-readable name of a specific audio device.
 *  Must be a value between 0 and (number of audio devices-1).
 *  Only valid after a successfully initializing the audio subsystem.
 *  The values returned by this function reflect the latest call to
 *  SDL_GetNumAudioDevices(); recall that function to redetect available
 *  hardware.
 *
 *  The string returned by this function is UTF-8 encoded, read-only, and
 *  managed internally. You are not to free it. If you need to keep the
 *  string for any length of time, you should make your own copy of it, as it
 *  will be invalid next time any of several other SDL functions is called.
 *}
function SDL_GetAudioDeviceName(index: Integer; iscapture: Integer): PAnsiChar;

{**
 *  Open a specific audio device. Passing in a device name of NULL requests
 *  the most reasonable default (and is equivalent to calling SDL_OpenAudio()).
 *
 *  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
 *  some drivers allow arbitrary and driver-specific strings, such as a
 *  hostname/IP address for a remote audio server, or a filename in the
 *  diskaudio driver.
 *
 *   0 on error, a valid device ID that is >= 2 on success.
 *
 *  SDL_OpenAudio(), unlike this function, always acts on device ID 1.
 *}
function SDL_OpenAudioDevice(device: PAnsiChar;
                             iscapture: Integer;
                             desired: PSDL_AudioSpec;
                             obtained: PSDL_AudioSpec;
							 allowed_changes: Integer): TSDL_AudioDeviceID;

{**
 *   Audio state
 *
 *  Get the current audio state.
 *}

typedef enum
{
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING,
    SDL_AUDIO_PAUSED
} SDL_AudioStatus;
extern DECLSPEC SDL_AudioStatus SDLCALL SDL_GetAudioStatus(void);

extern DECLSPEC SDL_AudioStatus SDLCALL
SDL_GetAudioDeviceStatus(SDL_AudioDeviceID dev);
{*Audio State*}

{**
 *   Pause audio functions
 *
 *  These functions pause and unpause the audio callback processing.
 *  They should be called with a parameter of 0 after opening the audio
 *  device to start playing sound.  This is so you can safely initialize
 *  data for your callback function after opening the audio device.
 *  Silence will be written to the audio device during the pause.
 *}

extern DECLSPEC void SDLCALL SDL_PauseAudio(int pause_on);
extern DECLSPEC void SDLCALL SDL_PauseAudioDevice(SDL_AudioDeviceID dev,
                                                  int pause_on);
/*@}*//*Pause audio functions*/

/**
 *  This function loads a WAVE from the data source, automatically freeing
 *  that source if \c freesrc is non-zero.  For example, to load a WAVE file,
 *  you could do:
 *  \code
 *      SDL_LoadWAV_RW(SDL_RWFromFile("sample.wav", "rb"), 1, ...);
 *  \endcode
 *
 *  If this function succeeds, it returns the given SDL_AudioSpec,
 *  filled with the audio data format of the wave data, and sets
 *  \c *audio_buf to a malloc()'d buffer containing the audio data,
 *  and sets \c *audio_len to the length of that audio buffer, in bytes.
 *  You need to free the audio buffer with SDL_FreeWAV() when you are
 *  done with it.
 *
 *  This function returns NULL and sets the SDL error message if the
 *  wave file cannot be opened, uses an unknown data format, or is
 *  corrupt.  Currently raw and MS-ADPCM WAVE files are supported.
 */
extern DECLSPEC SDL_AudioSpec *SDLCALL SDL_LoadWAV_RW(SDL_RWops * src,
                                                      int freesrc,
                                                      SDL_AudioSpec * spec,
                                                      Uint8 ** audio_buf,
                                                      Uint32 * audio_len);

/**
 *  Loads a WAV from a file.
 *  Compatibility convenience function.
 */
#define SDL_LoadWAV(file, spec, audio_buf, audio_len) \
    SDL_LoadWAV_RW(SDL_RWFromFile(file, "rb"),1, spec,audio_buf,audio_len)

/**
 *  This function frees data previously allocated with SDL_LoadWAV_RW()
 */
extern DECLSPEC void SDLCALL SDL_FreeWAV(Uint8 * audio_buf);

/**
 *  This function takes a source format and rate and a destination format
 *  and rate, and initializes the \c cvt structure with information needed
 *  by SDL_ConvertAudio() to convert a buffer of audio data from one format
 *  to the other.
 *
 *  \return -1 if the format conversion is not supported, 0 if there's
 *  no conversion needed, or 1 if the audio filter is set up.
 */
extern DECLSPEC int SDLCALL SDL_BuildAudioCVT(SDL_AudioCVT * cvt,
                                              SDL_AudioFormat src_format,
                                              Uint8 src_channels,
                                              int src_rate,
                                              SDL_AudioFormat dst_format,
                                              Uint8 dst_channels,
                                              int dst_rate);

/**
 *  Once you have initialized the \c cvt structure using SDL_BuildAudioCVT(),
 *  created an audio buffer \c cvt->buf, and filled it with \c cvt->len bytes of
 *  audio data in the source format, this function will convert it in-place
 *  to the desired format.
 *
 *  The data conversion may expand the size of the audio data, so the buffer
 *  \c cvt->buf should be allocated after the \c cvt structure is initialized by
 *  SDL_BuildAudioCVT(), and should be \c cvt->len*cvt->len_mult bytes long.
 */
extern DECLSPEC int SDLCALL SDL_ConvertAudio(SDL_AudioCVT * cvt);

#define SDL_MIX_MAXVOLUME 128
/**
 *  This takes two audio buffers of the playing audio format and mixes
 *  them, performing addition, volume adjustment, and overflow clipping.
 *  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME
 *  for full audio volume.  Note this does not change hardware volume.
 *  This is provided for convenience -- you can mix your own audio data.
 */
extern DECLSPEC void SDLCALL SDL_MixAudio(Uint8 * dst, const Uint8 * src,
                                          Uint32 len, int volume);

/**
 *  This works like SDL_MixAudio(), but you specify the audio format instead of
 *  using the format of audio device 1. Thus it can be used when no audio
 *  device is open at all.
 */
extern DECLSPEC void SDLCALL SDL_MixAudioFormat(Uint8 * dst,
                                                const Uint8 * src,
                                                SDL_AudioFormat format,
                                                Uint32 len, int volume);

/**
 *  \name Audio lock functions
 *
 *  The lock manipulated by these functions protects the callback function.
 *  During a SDL_LockAudio()/SDL_UnlockAudio() pair, you can be guaranteed that
 *  the callback function is not running.  Do not call these from the callback
 *  function or you will cause deadlock.
 */
/*@{*/
extern DECLSPEC void SDLCALL SDL_LockAudio(void);
extern DECLSPEC void SDLCALL SDL_LockAudioDevice(SDL_AudioDeviceID dev);
extern DECLSPEC void SDLCALL SDL_UnlockAudio(void);
extern DECLSPEC void SDLCALL SDL_UnlockAudioDevice(SDL_AudioDeviceID dev);
/*@}*//*Audio lock functions*/

/**
 *  This function shuts down audio processing and closes the audio device.
 */
extern DECLSPEC void SDLCALL SDL_CloseAudio(void);
extern DECLSPEC void SDLCALL SDL_CloseAudioDevice(SDL_AudioDeviceID dev);

/**
 * \return 1 if audio device is still functioning, zero if not, -1 on error.
 */
extern DECLSPEC int SDLCALL SDL_AudioDeviceConnected(SDL_AudioDeviceID dev);

